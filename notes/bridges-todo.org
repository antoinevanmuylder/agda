* TODOS
** TODO git issue #2: freshness messed up under lambdas
** TODO bridge vars always lock annotated? /!\ see git issue #3
pre bridges must be lock annoted? eg bridge form, intro. In other words should
we use lPi' vs nPi' when writing types in internal syntax?
(tick x : Lk) -> A x  is 'the type of affine sections of A' (A must be affine in x as well??)
when typechecking application s r, a freshness constraint CheckLockedVars is generated.

_conclusion of this was_: make cartesian dependency (x : Tick : LockU) -> bla(x)
into a tc error. instead, only affine dependency on ticks should be allowed (@tick x : Tick) -> bla(x)
also, have bridge vars always lock annotated in haskell code? dont
know if it has a real impact though
** TODO what works for path var should work for bridge var
~grep -r "path" src/full/Agda/TypeChecking/* --exclude="*.txt*" --exclude="*.err*" --exclude="*.agda*"~
its reasonnable to think that path implementation should have bridge counterpart
/!\ for constructors that is not true
below, some issues caused by a lack of bridge compatible telescope I think
*** DONE cannot define bridges with left application. b : BridgeP x.A a0 a1,  b i = ...
forced to do b = lam i -> ... for some reason
see insertImplicitPatternsT, L92 uses piOrPath. it should be piOrPath or bridge :>

#+begin_src 
(agda2-verbose "Checking IApply confluence of Cubical.Bridges.BridgeExamples.PlayBridgeP.mmk\n")
(agda2-verbose "length cls = 1\n")
(agda2-verbose "Debug printing tc.iapply:20 failed due to exception:\n  An internal error has occurred. Please report this as a bug.\n  Location of the error: impossible, called at src/full/Agda/TypeChecking/Rules/LHS.hs:746:95 in Agda-2.6.3-IDfR5qyJYA4K752vtcutk4:Agda.TypeChecking.Rules.LHS\n")
(agda2-verbose "compareTerm mmk f i0 = ?0 (f = f) (x = i0) : A₁ i0\n")
(agda2-verbose "compareTerm (not syntactically equal)\n  mmk f i0 = ?0 (f = f) (x = i0)\n  : A₁ i0\n")
(agda2-verbose "attempting shortcut ?0 (f = f) (x = i0) := mmk f i0\n")
(agda2-verbose "term ?0 (f = f) (x = i0) :DirEq mmk f i0\n")
(agda2-verbose "term ?0 (f = f) (x = i0) :DirEq mmk f i0\n")
(agda2-verbose "aborting: meta is frozen!\n")
(agda2-verbose "Solving awake constraints. 0 remaining.\n")
(agda2-verbose "{ compareTerm\n")
(agda2-verbose "compareTerm mmk f i0 = ?0 (f = f) (x = i0) : A₁ i0\n")
(agda2-verbose "{ compareAtom\n")
(agda2-verbose "compareAtom f bi0 = [ ?0 (f = f) (x = i0) ]_14 : A₁ i0\n")
(agda2-verbose "term ?0 (f = f) (x = i0) :DirEq f bi0\n")
(agda2-verbose "term ?0 (f = f) (x = i0) :DirEq f bi0\n")
(agda2-verbose "aborting: meta is frozen!\n")
(agda2-verbose "Solving awake constraints. 0 remaining.\n")
(agda2-verbose "adding constraint mmk f i0 = ?0 (f = f) (x = i0) : A₁ i0\n                    (blocked on _14)\n")
#+end_src
the compareTerm call is issued by compareTermOnFace
So something calls this cubical function and should be calling
a bridge aware function instead. --> it is equalTermOnFace which
is probably called in IApplyConfluence.hs?
~grep -r "equalTermOnFace" .*/~ is ok

TODO in checkIApplyConfluence I have to generate bridge boundary constraints under
some (unclear at the time) conditions. the second part of the code ~case _ of MetaV~
must also be updated with bridges?
*** DONE cannot refine C-c C-r and automatically intro bridge vars
*** DONE Metvars:1248:7 ~__IMPOSSIBLE__~ is reached
because of telViewUpToPathBoundary'
*** _partial solution_
Part of these bugs come from the fact that functions building and handling telescopes
don't work for bridge variables
Our solution is to write copies of the said functions in ~Telescope.hs~ that
are bridge aware. We keep both versions around because sometimes we indeed want
to exclude bridges from the analysis. example: constructors of data type can not
be bridges.
Below we list the points in the code base that were made bridge aware
We only applied these modifications when we were sure that it would behave well.
There are several places where a bridge awareness modification should probably appear
and several where it should probably not, our default strategy being "stick to old
implementation"
#+begin_src
[bridges] Make several functions use bridge-aware telescope methods 

Below, TC is shorthand for TypeChecking/ directory.

 - piOrPath in insertImplicitBindersT1 in TC/Implicit.hs

 - piOrPath in insertImplicitPatternsT in TC/Rules/LHS/Implicit.hs

 - isPath, telViewUpToPathBoundary' in splitResultPath in TC/Coverage.hs

 - telViewUpToPathBoundary in assignMeta' in TC/MetaVars.hs

 - telViewUpToPathBoundary in checkMetaInst in TC/MetaVars.hs

 - telViewUpToPathBoundaryP in updateProblemRest in
   TC/Rules/LHS/ProblemRest.hs

 - telViewPath in typeEndsInDef in Termination/TermCheck.hs

 - telViewPath in setMasks in Terminataion/TermCheck.hs

 - telViewPath in setMasks in Terminataion/TermCheck.hs

 - telViewPath in introTactic in Interaction/BasicOps.hs
#+end_src

** TODO computational behaviour of transport, composition should take BridgeP and Gel into account!
those are operators whose operational behaviour is defined by casing on types
We currently lack the BridgeP/ Gel cases
** TODO my impl as an instance of popl18 stuff, for paper soundness prf
** TODO go through CH paper and formalize their easy examples
** TODO various bugs
*** DONE MetaVars.hs:1248:8
this bug is triggered when typechecking 1 retract proof of the bridge vs functions principle (the one normally using extent eta)
an ~__IMPOSSIBLE__~ is reached

the tc tries to solve a "meta equation" ~x ids = u~ where x has type
~{lA lB A B} N0 N1 q -> BridgeP (x. PI A B) (_a0_56, _a1_57)~
and ids has lenght 8, u is ~\a -> q x a~
so it uses _telViewUpToPathBoundary_ to extract a telescope but this
function stops when it sees a bridge type (it should instead introduce
a bridge variable)
*** DONE Sort.hs:220:30
*** DONE Bridges.hs:179
the case where r is a meta is not implemented I think
** --------------
** TODO there are TODO-antva's lying around. + comment in Bridges.hs
** TODO semifreshness by freshness?
** TODO metas are badly handled for now
** TODO see github issues for more severe issues.
for instance: #2 is about lack of computation under lambdas for extent.
** TODO sometimes argN and argH must be argL
** TODO extend internal checker
this sanity checker should be extended to make CH ~Internal~ syntax pass
note that the checker is disabled by default
** TODO extend compiler
** DONE make sure that current impl of definitional equality allows extent eta to be proved
see rule 6.7 of https://arxiv.org/pdf/1901.00489.pdf
the technique used to prove path extent-eta is I think the same for the bridge vs iso principle
and the latter implies relativity
** DONE if a (semi)freshness analysis fails, some error should be raised?
semi freshness when computing: see extent-beta/Gel-eta
freshness when typechecking: see TypeChecking/Rules/ pbly

_guess_:
  in extent beta, if semi freshness fails, just don't fire the red.
  freshness checks other than in Gel-eta are by typing and can lead to tc errors (as expected).
  freshness in Gel eta? by raising freshness cstr? see gel eta --> by typing too actually!
  semifreshness in gel eta: should specify to conversion alg that gel eta wont conclude.
** DONE must generate more freshness constraints
sometimes rules in CH ask for apartedness (freshness) but no check is performed here
I wonder if a PrimitiveImpl is really the place to have those freshness checks (except
right before a computation). I should have more constraints generated during typechecking instead?
r fresh for M means in particular that r not in fv M. since BI is registered a timeless
I should make sure that the freshness constraint wants no r in fvM.

_conclusion_ Andrea: have (@tick r : BI) at the end
the trick only works partly for Gel eta. see there.
seems good even in Gel eta now
** DONE correct Gel eta
*** DONE what to do when semi freshness fails
I raise a pattern error, in other words I 'give up'. see ~compareGelTm~
*** DONE freshness for Gel eta args
l A0 A1 R and ~absQ : (@tick x : BI) -> Gel A0 A1 R x~
are required to be r-before's (iff r fresh for them iff l A0 A1 R absQ (@tick r : BI) well formed ctx)
in the premisses of CH Gel eta rule. I don't have this check for now in my impl.

it is ok by typing and semi freshness
*** DONE break loop in Gel eta
when comparing m and n, Gel eta tries to compare ungel( x.m ) vs ungel ( x.n )
as it is done for Glue eta.
In that case, the circularity is circumvented in the compareAtom function (  unglue vs unglue leads
to a compareAtom call), more specifically in the compareEtaPrims where-func.
I think I have to implement something similar!
*** semifreshness by freshness constraint
in extent beta, one can not raise contstraints anyway
but in Gel eta it is possible. so possible to encode semifreshness by raising a freshness cstr?
** DONE should check the universe levels in the type of my primitives
Andrea: having A0 A1 R at same level is the way to go
** DONE CH does not say how cubical composition acts on bridge types?
not relevant
